<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="What sphericart computes" href="maths.html" /><link rel="prev" title="PyTorch API" href="pytorch-api.html" />

    <!-- Generated with Sphinx 6.2.1 and Furo 2023.03.27 -->
        <title>Usage and examples - sphericart documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">sphericart  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">sphericart  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="api.html">API documentation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="cpp-api.html">C++ API</a></li>
<li class="toctree-l2"><a class="reference internal" href="c-api.html">C API</a></li>
<li class="toctree-l2"><a class="reference internal" href="python-api.html">Python API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pytorch-api.html">PyTorch API</a></li>
</ul>
</li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Usage and examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="maths.html">What sphericart computes</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="usage-and-examples">
<h1>Usage and examples<a class="headerlink" href="#usage-and-examples" title="Permalink to this heading">#</a></h1>
<p><cite>sphericart</cite> is a multi-language library, providing similar interfaces across different
programming languages, adapting to the typical usage patterns for the language. In general,
the calculators must be initialized first, to allocate buffers and initialize constant
factors that are used in the calculation. Then, spherical harmonics and their derivatives
can be computed for an array of 3D Cartesian points.</p>
<p>This section provides a series of examples, that are also part of the source code repository
and are tested for consistency, that perform the same task: computing Cartesian spherical harmonics for
a random array of Cartesian coordinates, using either 32-bit or 64-bit floating-point
arithmetics, evaluating the mean relative error between the two precision levels.</p>
<section id="c">
<h2>C++<a class="headerlink" href="#c" title="Permalink to this heading">#</a></h2>
<p>The <cite>SphericalHarmonics</cite> class initializes and stores internally pre-factors and
buffers, but the <cite>compute</cite> and <cite>compute_with_gradients</cite> functions require pre-allocated
<cite>std::vector</cite> to hold the results. See the <a class="reference internal" href="api.html"><span class="doc">API documentation</span></a> for alternative
calls using bare arrays or individual samples.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/** @file example.cpp</span>
<span class="cm"> *  @brief Usage example for the C++ API</span>
<span class="cm">*/</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sphericart.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* ===== set up the calculation ===== */</span>

<span class="w">    </span><span class="c1">// hard-coded parameters for the example</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">l_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// initializes samples</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">RAND_MAX</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// to avoid unnecessary allocations, calculators use pre-allocated memory</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">dsph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// the class is templated, so one can also use 32-bit float operations</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">xyz_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">xyz_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sph_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">dsph_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// the class can be used to compute the for a full arrays of points (as</span>
<span class="w">    </span><span class="c1">// above) or on individual samples - this is deduced from the size of the array</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">xyz_sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sph_sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">((</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">dsph_sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="cm">/* ===== API calls ===== */</span>

<span class="w">    </span><span class="c1">// internal buffers and numerical factors are initalized at construction</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sphericart</span><span class="o">::</span><span class="n">SphericalHarmonics</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l_max</span><span class="p">);</span>

<span class="w">    </span><span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">);</span><span class="w"> </span><span class="c1">// no gradients</span>
<span class="w">    </span><span class="n">calculator</span><span class="p">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">,</span><span class="w"> </span><span class="n">dsph</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// the single-sample evaluation provides direct access to the main calculator,</span>
<span class="w">    </span><span class="c1">// avoiding the loop over samples and allowing e.g. custom parallelization</span>
<span class="w">    </span><span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz_sample</span><span class="p">,</span><span class="w"> </span><span class="n">sph_sample</span><span class="p">);</span><span class="w"> </span><span class="c1">// no gradients</span>
<span class="w">    </span><span class="n">calculator</span><span class="p">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz_sample</span><span class="p">,</span><span class="w"> </span><span class="n">sph_sample</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_sample</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// float version</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">calculator_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sphericart</span><span class="o">::</span><span class="n">SphericalHarmonics</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l_max</span><span class="p">);</span>
<span class="w">    </span><span class="n">calculator_f</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz_f</span><span class="p">,</span><span class="w"> </span><span class="n">sph_f</span><span class="p">);</span><span class="w"> </span><span class="c1">// no gradients</span>
<span class="w">    </span><span class="n">calculator_f</span><span class="p">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz_f</span><span class="p">,</span><span class="w"> </span><span class="n">sph_f</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_f</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ===== check results ===== */</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">sph_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">sph_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="p">(</span><span class="n">l_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">l_max</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sph_error</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">sph_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">sph_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">sph_norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Float vs double relative error: %12.8e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">sph_error</span><span class="o">/</span><span class="n">sph_norm</span><span class="p">));</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id1">
<h2>C<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<p>The C API uses an opaque type <cite>sphericart_calculator_t</cite> to hold a reference to the
C++ implementation of a <cite>SphericalHarmonics</cite> object. Several functions that mimic
the methods of the class can be called to compute spherical harmonics and their
derivatives.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/** @file example.c</span>
<span class="cm"> *  @brief Usage example for the C API</span>
<span class="cm">*/</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sphericart.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stdio.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stdlib.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;math.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* ===== set up the calculation ===== */</span>

<span class="w">    </span><span class="c1">// hard-coded parameters for the example</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">l_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// initializes samples</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">RAND_MAX</span><span class="w"> </span><span class="o">*</span><span class="mf">2.0-1.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// to avoid unnecessary allocations, the class assumes pre-allocated arrays</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sph_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">sph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">sph_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dsph_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l_max</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">dsph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">dsph_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// float versions</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">xyz_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">n_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">xyz_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">sph_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">sph_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">dsph_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">dsph_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* ===== API calls ===== */</span>

<span class="w">    </span><span class="c1">// opaque pointer declaration: initializes buffers and numerical factors</span>
<span class="w">    </span><span class="n">sphericart_calculator_t</span><span class="o">*</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sphericart_new</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// function calls</span>
<span class="w">    </span><span class="c1">// without derivatives</span>
<span class="w">    </span><span class="n">sphericart_compute_array</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_samples</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">,</span><span class="w"> </span><span class="n">sph_size</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// with derivatives</span>
<span class="w">    </span><span class="n">sphericart_compute_array_with_gradients</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_samples</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">,</span><span class="w"> </span><span class="n">sph_size</span><span class="p">,</span><span class="w"> </span><span class="n">dsph</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_size</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// per-sample calculation - we reuse the same arrays, but only the first item is computed</span>
<span class="w">    </span><span class="n">sphericart_compute_sample</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">,</span><span class="w"> </span><span class="n">sph_size</span><span class="p">);</span>
<span class="w">    </span><span class="n">sphericart_compute_sample_with_gradients</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span><span class="w"> </span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">sph</span><span class="p">,</span><span class="w"> </span><span class="n">sph_size</span><span class="p">,</span><span class="w"> </span><span class="n">dsph</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_size</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// float version</span>
<span class="w">    </span><span class="n">sphericart_calculator_f_t</span><span class="o">*</span><span class="w"> </span><span class="n">calculator_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sphericart_new_f</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">sphericart_compute_array_with_gradients_f</span><span class="p">(</span><span class="n">calculator_f</span><span class="p">,</span><span class="w"> </span><span class="n">xyz_f</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_samples</span><span class="p">,</span><span class="w"> </span><span class="n">sph_f</span><span class="p">,</span><span class="w"> </span><span class="n">sph_size</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_f</span><span class="p">,</span><span class="w"> </span><span class="n">dsph_size</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ===== check results ===== */</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">sph_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">sph_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_samples</span><span class="o">*</span><span class="p">(</span><span class="n">l_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">l_max</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sph_error</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">sph_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">sph_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">sph_norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">sph</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Float vs double relative error: %12.8e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">sph_error</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sph_norm</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* ===== clean up ===== */</span>

<span class="w">    </span><span class="c1">// frees up data arrays and sph object pointers</span>
<span class="w">    </span><span class="n">sphericart_delete</span><span class="p">(</span><span class="n">calculator</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">xyz</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">sph</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">dsph</span><span class="p">);</span>

<span class="w">    </span><span class="n">sphericart_delete_f</span><span class="p">(</span><span class="n">calculator_f</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">xyz_f</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">sph_f</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">dsph_f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="python">
<h2>Python<a class="headerlink" href="#python" title="Permalink to this heading">#</a></h2>
<p>The <cite>Python</cite> API relies on a
<a class="reference internal" href="python-api.html#sphericart.SphericalHarmonics" title="sphericart.SphericalHarmonics"><code class="xref py py-class docutils literal notranslate"><span class="pre">sphericart.SphericalHarmonics</span></code></a>  class
and is used in a similar way to the C++ classes, with the
difference that, in line with pythonic mores, the
<cite>compute</cite> methods allocate and return their own arrays.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">sphericart</span>

<span class="n">docstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">An example of the use of the Python interface of the `sphericart` library.</span>

<span class="s2">Simply computes Cartesian spherical harmonics for the given parameters, for an</span>
<span class="s2">array of random 3D points, using both 32-bit and 64-bit arithmetics. </span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">sphericart_example</span><span class="p">(</span><span class="n">l_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># `sphericart` provides a SphericalHarmonics object that initializes the</span>
    <span class="c1"># calculation and then can be called on any n x 3 arrays of Cartesian</span>
    <span class="c1"># coordinates. It computes _all_ SPH up to a given l_max, and can compute</span>
    <span class="c1"># scaled (default) and normalized (standard Ylm) harmonics.</span>

    <span class="c1"># ===== set up the calculation =====</span>

    <span class="c1"># initializes the Cartesian coordinates of points</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># float32 version</span>
    <span class="n">xyz_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># ===== API calls =====</span>

    <span class="n">sh_calculator</span> <span class="o">=</span> <span class="n">sphericart</span><span class="o">.</span><span class="n">SphericalHarmonics</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">)</span>

    <span class="c1"># without gradients</span>
    <span class="n">sh_sphericart</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

    <span class="c1"># with gradients</span>
    <span class="n">sh_sphericart</span><span class="p">,</span> <span class="n">dsh_sphericart</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

    <span class="c1"># the same calculator automatically chooses between float64 and float32</span>
    <span class="n">sh_sphericart_f</span><span class="p">,</span> <span class="n">dsh_sphericart_f</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz_f</span><span class="p">)</span>

    <span class="c1"># ===== check results =====</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Float vs double relative error: </span><span class="si">%12.8e</span><span class="s2">&quot;</span>
        <span class="o">%</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sh_sphericart</span> <span class="o">-</span> <span class="n">sh_sphericart_f</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sh_sphericart</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="n">docstring</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-l&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;maximum angular momentum&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;number of samples&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--normalized&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;compute normalized spherical harmonics&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># Process everything.</span>
    <span class="n">sphericart_example</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pytorch">
<h2>PyTorch<a class="headerlink" href="#pytorch" title="Permalink to this heading">#</a></h2>
<p>The <cite>PyTorch</cite> implementation follows closely the syntax and usage of the
<cite>Python</cite> implementation, but also supports backpropagation.
The example shows how to compute gradients relative to the input
coordinates by using <cite>backwards</cite>.
The <a class="reference internal" href="pytorch-api.html#sphericart.torch.SphericalHarmonics" title="sphericart.torch.SphericalHarmonics"><code class="xref py py-class docutils literal notranslate"><span class="pre">sphericart.torch.SphericalHarmonics</span></code></a> object can also
be used inside a <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code></a>, that can then be
compiled using <cite>torchscript</cite>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">import</span> <span class="nn">sphericart.torch</span>


<span class="n">docstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">An example of the use of the PyTorch interface of the `sphericart` library.</span>

<span class="s2">Simply computes Cartesian spherical harmonics for the given parameters, for an</span>
<span class="s2">array of random 3D points, using both 32-bit and 64-bit arithmetics.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SHModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Example of how to use SphericalHarmonics from within a</span>
<span class="sd">    `torch.nn.Module`&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_max</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sph</span> <span class="o">=</span> <span class="n">sphericart</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SphericalHarmonics</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
        <span class="n">sph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sph</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sph</span>


<span class="k">def</span> <span class="nf">sphericart_example</span><span class="p">(</span><span class="n">l_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># `sphericart` provides a SphericalHarmonics object that initializes the</span>
    <span class="c1"># calculation and then can be called on any n x 3 arrays of Cartesian</span>
    <span class="c1"># coordinates. It computes _all_ SPH up to a given l_max, and can compute</span>
    <span class="c1"># scaled (default) and normalized (standard Ylm) harmonics.</span>

    <span class="c1"># ===== set up the calculation =====</span>

    <span class="c1"># initializes the Cartesian coordinates of points</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="c1"># float32 version</span>
    <span class="n">xyz_f</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="c1"># ===== API calls =====</span>

    <span class="n">sh_calculator</span> <span class="o">=</span> <span class="n">sphericart</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SphericalHarmonics</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">)</span>

    <span class="c1"># the interface allows to return directly the forward derivatives,</span>
    <span class="c1"># similar to the Python version</span>
    <span class="n">sh_sphericart</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">sh_sphericart</span><span class="p">,</span> <span class="n">dsh_sphericart</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

    <span class="n">sh_sphericart_f</span><span class="p">,</span> <span class="n">dsh_sphericart_f</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute_with_gradients</span><span class="p">(</span><span class="n">xyz_f</span><span class="p">)</span>

    <span class="c1"># ===== check results =====</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Float vs double relative error: </span><span class="si">%12.8e</span><span class="s2">&quot;</span>
        <span class="o">%</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sh_sphericart</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="o">-</span> <span class="n">sh_sphericart_f</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sh_sphericart</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># ===== autograd integration =====</span>

    <span class="c1"># the implementation also supports backpropagation.</span>
    <span class="c1"># the input tensor must be tagged to have `requires_grad`</span>
    <span class="n">xyz_ag</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
    <span class="n">sh_sphericart</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz_ag</span><span class="p">)</span>

    <span class="c1"># then the spherical harmonics **but not their derivatives**</span>
    <span class="c1"># can be used with the usual PyTorch backward() workflow</span>
    <span class="n">sph_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sh_sphericart</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sph_norm</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

    <span class="c1"># checks the derivative is correct using the forward call</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">xyz_ag</span><span class="o">.</span><span class="n">grad</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iaj,ij-&gt;ia&quot;</span><span class="p">,</span> <span class="n">dsh_sphericart</span><span class="p">,</span> <span class="n">sh_sphericart</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Check derivative difference: </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># ===== torchscript integration =====</span>
    <span class="n">xyz_jit</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="n">module</span> <span class="o">=</span> <span class="n">SHModule</span><span class="p">(</span><span class="n">l_max</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span>

    <span class="c1"># JIT compilation of the module</span>
    <span class="n">script</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">sh_jit</span> <span class="o">=</span> <span class="n">script</span><span class="p">(</span><span class="n">xyz_jit</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jit vs direct call: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sh_jit</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sh_sphericart</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># ===== GPU implementation ======</span>

    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

        <span class="n">sh_sphericart_cuda</span><span class="p">,</span> <span class="n">dsh_sphericart_cuda</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute_with_gradients</span><span class="p">(</span>
            <span class="n">xyz</span>
        <span class="p">)</span>

        <span class="n">norm_dsph</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dsh_sphericart_cuda</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">dsh_sphericart</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Check fw derivative difference CPU vs CUDA: </span><span class="si">{</span><span class="n">norm_dsph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">xyz_cuda</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
        <span class="n">sh_sphericart_cuda</span> <span class="o">=</span> <span class="n">sh_calculator</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">xyz_cuda</span><span class="p">)</span>

        <span class="c1"># then the spherical harmonics **but not their derivatives**</span>
        <span class="c1"># can be used with the usual PyTorch backward() workflow</span>
        <span class="n">sph_norm_cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sh_sphericart_cuda</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sph_norm_cuda</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xyz_ag</span><span class="o">.</span><span class="n">grad</span> <span class="o">-</span> <span class="n">xyz_cuda</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="n">xyz_ag</span><span class="o">.</span><span class="n">grad</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Check derivative difference CPU vs CUDA: </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="n">docstring</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-l&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;maximum angular momentum&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;number of samples&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--normalized&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;compute normalized spherical harmonics&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># Process everything.</span>
    <span class="n">sphericart_example</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="maths.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">What sphericart computes</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="pytorch-api.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">PyTorch API</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, sphericart developers
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Usage and examples</a><ul>
<li><a class="reference internal" href="#c">C++</a></li>
<li><a class="reference internal" href="#id1">C</a></li>
<li><a class="reference internal" href="#python">Python</a></li>
<li><a class="reference internal" href="#pytorch">PyTorch</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    </body>
</html>